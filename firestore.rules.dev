rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() { return request.auth != null; }
    function userRole() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }
    function isTeacher() { return isSignedIn() && userRole() in ['teacher', 'admin']; }
    function isStudent() { return isSignedIn() && userRole() == 'student'; }
    function isOwner(uid) { return isSignedIn() && uid == request.auth.uid; }

    // users
    match /users/{uid} {
      allow read: if isSignedIn();
      allow write: if request.auth.uid == uid || isTeacher();
    }

    // classes
    match /classes/{id} {
      allow read: if isSignedIn();
      allow create: if isTeacher() && isOwner(request.resource.data.ownerUid);
      allow update, delete: if isTeacher() && isOwner(resource.data.ownerUid);
    }

    // problems
    match /problems/{id} {
      allow read: if isSignedIn();
      allow create: if isTeacher() && isOwner(request.resource.data.ownerUid);
      allow update, delete: if isTeacher() && isOwner(resource.data.ownerUid);
    }

    // assignments
    match /assignments/{id} {
      allow read: if isSignedIn();
      allow create: if isTeacher() && isOwner(request.resource.data.ownerUid);
      allow update, delete: if isTeacher() && isOwner(resource.data.ownerUid);
    }

    // attempts (actualizado)
    match /attempts/{id} {

      // Crea el propio alumno (acepta userUid o studentUid)
      function isSelfCreate() {
        let d = request.resource.data;
        return isSignedIn() && (
          (('userUid' in d) && d.userUid == request.auth.uid) ||
          (('studentUid' in d) && d.studentUid == request.auth.uid)
        );
      }

      // Dueño del intento existente
      function isSelfExisting() {
        return isSignedIn() && (
          resource.data.userUid == request.auth.uid ||
          (('studentUid' in resource.data) && resource.data.studentUid == request.auth.uid)
        );
      }

      // Esquema válido al crear:
      // - viejo: problemId
      // - nuevo: assignmentId + answers[]
      function shapeIsValidOnCreate() {
        let d = request.resource.data;
        return (('problemId' in d) && d.problemId is string)
            || (('assignmentId' in d) && d.assignmentId is string && ('answers' in d));
      }

      // Crear: alumno para sí mismo + ownerUid presente + shape válido
      allow create: if isStudent()
        && isSelfCreate()
        && (request.resource.data.ownerUid is string)
        && shapeIsValidOnCreate();

      // Actualizar: el alumno dueño mientras no esté finalizado
      allow update: if isSelfExisting() && resource.data.finishedAt == null;

      // Leer: alumno dueño o teacher owner
      allow get, list: if isSignedIn() && (
        isSelfExisting() || isOwner(resource.data.ownerUid)
      );

      // Borrar: solo el teacher dueño
      allow delete: if isTeacher() && isOwner(resource.data.ownerUid);
    }

    // fallback
    match /{document=**} {
      allow read: if isSignedIn();
      allow write: if false;
    }
  }
}

